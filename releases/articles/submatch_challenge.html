
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>Fast submatch extraction &#8212; re2c 1.2 documentation</title>
    <link rel="stylesheet" href="../../_static/theme-re2c.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <link rel="shortcut icon" href="../../_static/favicon.ico"/>
    <link rel="alternate" type="application/atom+xml" href="../../feed/atom.xml" title="Atom 1.0" />
    
 
  </head><body>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper"><div class="re2c-logo">
    re2c
</div>

<h3><a href="../../index.html">Home</a></h3>
<div class="re2c-toc-global">
    <ul>
<li class="toctree-l1"><a class="reference internal" href="../../manual/manual.html">User manual</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../install/install.html">Build instructions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../release_notes.html">Release notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../changelog/changelog.html">Changelog</a></li>
</ul>

</div>
    <h3>Fast submatch extraction</h3>
    <div class="re2c-toc-local">
        <ul>
<li><a class="reference internal" href="#">Fast submatch extraction</a><ul>
<li><a class="reference internal" href="#introduction">Introduction</a></li>
<li><a class="reference internal" href="#recognition">Recognition</a></li>
<li><a class="reference internal" href="#the-difficulty-with-dfa">The difficulty with DFA</a></li>
<li><a class="reference internal" href="#dangerous-trailing-contexts">Dangerous trailing contexts</a></li>
</ul>
</li>
</ul>

    </div>

        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="fast-submatch-extraction">
<h1>Fast submatch extraction<a class="headerlink" href="#fast-submatch-extraction" title="Permalink to this headline">¶</a></h1>
<p><em>by Ulya Trofimovich</em></p>
<p>This article is an informal description
of the <a class="reference external" href="../../2017_trofimovich_tagged_deterministic_finite_automata_with_lookahead.pdf">novel algorithm</a>
used in <a class="reference external" href="../release_notes/1_0.html">re2c-1.0</a>
to implement <a class="reference external" href="../../manual/features/submatch/submatch.html">submatch extraction</a>.
It tries to explain what is it so complex about this seemingly simple problem,
why re2c has such a strange interface,
and how <em>tags</em> are related to the familiar <em>capturing groups</em> used by other regular expression engines.</p>
<div class="section" id="introduction">
<h2>Introduction<a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h2>
<p><em>Regular expressions</em> is a syntactic notation for describing <em>sets</em>.
Usually it is assumed that these sets contain strings — sequences of characters over some fixed alphabet.
This is known as the <em>language interpretation</em> of regular expressions.
For example, <img class="math" src="../../_images/math/dd74dc5c9418a329ecbe0073e1fe05190eda9a85.png" alt="a^*b^*" style="vertical-align: 0px"/> denotes language <img class="math" src="../../_images/math/48db08e51669ad87af374b5f0fd4dacbb2de0ea6.png" alt="L" style="vertical-align: 0px"/> that contains all strings
composed by a sequence of <img class="math" src="../../_images/math/2a3e6468d8e8436144abc2ac7a0eba94cfcf8833.png" alt="a" style="vertical-align: 0px"/> followed by a sequence of <img class="math" src="../../_images/math/9a35981bab3fb1e23a2f374e4a027a565471a18d.png" alt="b" style="vertical-align: 0px"/>.
Special symbol <img class="math" src="../../_images/math/5c6c23b13e59ef813dcae81710428f8e21fee05f.png" alt="\epsilon" style="vertical-align: 0px"/> means “empty string”:</p>
<div class="math">
<p><img src="../../_images/math/31c6035d057f521b139d5008dc46cc0ac4ad0d35.png" alt="L(a^*b^*) = \{\epsilon, a, b, aa, ab, bb, ...\}"/></p>
</div><p>Regular expressions is one possible way of describing <em>regular languages</em> —
the class of languages generated by Type 3 grammars in the Chomsky hierarchy.
For every regular expression there is an equivalent Type 3 grammar that generates the same language and vice versa.
For example, the above language <img class="math" src="../../_images/math/48db08e51669ad87af374b5f0fd4dacbb2de0ea6.png" alt="L" style="vertical-align: 0px"/> can be generated by the grammar <img class="math" src="../../_images/math/86719de2b4bb24ecfb2b5fe5d28bfce049432409.png" alt="G = (V_T, V_N, R, S)" style="vertical-align: -5px"/>:</p>
<div class="math">
<p><img src="../../_images/math/0037694037d3a71e41413578cd234edd3d833051.png" alt="\text{alphabet of terminals:} &amp;\quad     V_T = \{ a, b \} \\
\text{alphabet of non-terminals:} &amp;\quad V_N = \{ A, B \} \\
\text{production rules:} &amp;\quad          R = \{
A \rightarrow aA | bB | a | b | \epsilon,
B \rightarrow bB | b
\} \\
\text{start symbol:} &amp;\quad S = A"/></p>
</div><p>It is often said that regular expressions are used for <em>matching</em> strings.
But what exactly is matching?
In the narrow sense of the word it means <em>recognition</em>:
deciding if the given string belongs to the language denoted by the regular expression.
For example, <img class="math" src="../../_images/math/b343a75f21850f283e7a9052c6d4e429e86f2fdf.png" alt="aaabb \in L" style="vertical-align: -1px"/>, but <img class="math" src="../../_images/math/f4797cf166ba72d581981b92f88fef1e2eb77d04.png" alt="aba \not\in L" style="vertical-align: -4px"/>.
In the broad sense of the word matching means <em>parsing</em>:
besides solving the membership problem
it is also necessary to find the <em>derivation</em> — the sequence of grammar rules that transform start symbol into the input string.
Derivation gives more information than a simple membership test
because it reconstructs the <em>structure</em> of the input string.
For example, <img class="math" src="../../_images/math/bd301c72d768733527c1682f02f6ead4568d4881.png" alt="aaabb" style="vertical-align: 0px"/> is derived as follows in the grammar <img class="math" src="../../_images/math/58480c8cf19c69c3af184a56ed6985d65b9b244f.png" alt="G" style="vertical-align: 0px"/>:</p>
<div class="math">
<p><img src="../../_images/math/928ce57bd007871a404e32870db45b88533e1b76.png" alt="A
\rightarrow aA
\rightarrow aaA
\rightarrow aaaA
\rightarrow aaabB
\rightarrow aaabb"/></p>
</div><p>There is no exact analogue of “derivation” in terms of regular expressions,
as their primary application is recognition, not parsing.
Yet sometimes it is convenient to know which part of the input string
corresponds to a particular part of the regular expression —
the problem known as <em>submatch extraction</em>.
In our example one might want to know the substrings corresponding to <img class="math" src="../../_images/math/3235fa0f6f8e4a39a6a3498583f5b7de4138e058.png" alt="a^*" style="vertical-align: 0px"/> and <img class="math" src="../../_images/math/7da27f7d74eb31b3c2cd639dad0f41bcbcb7688a.png" alt="b^*" style="vertical-align: 0px"/>;
this is usually denoted with the help of <em>capturing parentheses</em>: <img class="math" src="../../_images/math/c75680b8275f933e71a564f1e7c4b7948de56152.png" alt="(a^*)(b^*)" style="vertical-align: -5px"/>.
Submatch extraction is similar to parsing:
in order to find submatch boundaries we need to know a bit of the input structure.
However, unlike parsing, there is no need to reconstruct the full structure down to each character.</p>
<div class="math">
<p><img src="../../_images/math/3a6bd8b5c62ffa658aaf86378127d64d5e03c433.png" alt="\underbrace{aaa}_{a^*} \underbrace{bb}_{b^*}"/></p>
</div><p>Recognition problem can be solved by converting the regular expression to a <em>nondeterministic finite automaton</em> (NFA)
or an equivalent <em>deterministic finite automaton</em> (DFA).
Parsing and submatch extraction are inherently more complex than recognition,
and they require a more complex type of automata: <em>nondeterministic finite state transducers</em> (NFST).
Unlike NFA, NFST are strictly more powerful than their deterministic analogues (DFST):
it is possible to perform determinization, but the resulting automaton is of a more sophisticated type than DFST.</p>
</div>
<div class="section" id="recognition">
<h2>Recognition<a class="headerlink" href="#recognition" title="Permalink to this headline">¶</a></h2>
<img alt="../../_images/nfa_simple.png" src="../../_images/nfa_simple.png" />
<p>aaaa</p>
<img alt="../../_images/nfa.png" src="../../_images/nfa.png" />
<p>aaaa</p>
<img alt="../../_images/dfa_raw.png" src="../../_images/dfa_raw.png" />
<p>aaaaa</p>
<img alt="../../_images/dfa.png" src="../../_images/dfa.png" />
<p>aaaa</p>
<img alt="../../_images/dfa_min.png" src="../../_images/dfa_min.png" />
<p>Recognition problem can be solved by converting the regular expression to a <em>nondeterministic finite automaton</em> (NFA)
and simulating NFA moves on the input string.
Simulation takes linear time, but since the automaton is nondeterministic,
it is necessary to track many possible paths simultaneously.
Alternatively, one can convert NFA to an equivalent <em>deterministic finite automaton</em> (DFA),
which also runs in linear time, but is much faster then NFA — there is only one possible path to track.
The <em>determinization</em> procedure is quite complex;
in the worst case it may take exponential time and generate a very large DFA.
Therefore determinization is only worthwile
if it can be performed ahead of time (in lexer generators like re2c),
or if the same regular expression is used multiple times.
Some engines try to get the best of both worlds by using <em>lazy determinization</em>:
NFA simulation with memoization of all intermediate states.</p>
<p>In terms of NFA “derivation” means “path”,
and parsing means finding this path — a chain of transitions from initial state to final state which spells the input string.
This cannot be done by the means of traditional NFA,
as the only output they produce is a yes/no answer:
simulation either ends in a final state or not.
In order to remember the path automaton must be able to record its moves.
Such automata are known as <em>nondeterministic finite state transducers</em> (NFST):
they are like ordinary NFA extended with an output tape
and transitions that not only read symbols from the input string, but also write symbols on the output tape.
Unlike NFA, NFST cannot be always converted to DFST: nondeterminisitc transducers are strictly more powerful.
However, it is possible to turn NFST into a more complex type of determinisitc automata.
Devising and constructing such automata is the main challenge of parsing and submatch extraction.</p>
</div>
<div class="section" id="the-difficulty-with-dfa">
<h2>The difficulty with DFA<a class="headerlink" href="#the-difficulty-with-dfa" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="dangerous-trailing-contexts">
<h2>Dangerous trailing contexts<a class="headerlink" href="#dangerous-trailing-contexts" title="Permalink to this headline">¶</a></h2>
<p>The challenge of implementing submatch extraction in lexer generators like re2c is not immediately obvious.</p>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer" role="contentinfo">
      Last updated on Dec 25, 2019.
    </div>
  </body>
</html>